
import Foundation

let usage = """
USAGE: generate-secrets <env-path> <output-path>

ARGUMENTS:
  <env-path>              The input .env file path
  <output-path>           The output generated file path

OPTIONS:
  -h, --help              Show help information.
"""

if CommandLine.arguments.contains("-h") || CommandLine.arguments.contains("--help") {
    print(usage)
    exit(0)
}

// MARK: - Parse Arguments
let envPath = CommandLine.arguments[safe: 1]
let outPath = CommandLine.arguments[safe: 2]

guard let envPath else {
    print("error: Missing expected argument '<env-path>'")
    print(usage)
    exit(1)
}

guard let outPath else {
    print("error: Missing expected argument '<out-path>'")
    print(usage)
    exit(1)
}

// MARK: - Read & Parse file

guard FileManager.default.fileExists(atPath: envPath) else {
    print("warning: No .env file exists at path \(envPath)")
    exit(0)
}

let env = try String(contentsOfFile: envPath)

let quotesCharacterSet = CharacterSet(charactersIn: #""'"#)

var lines = env.split(separator: "\n")

let prefix = lines
    .first(where: { $0.hasPrefix("#prefix ") })?
    .suffix(from: "#prefix ")
    .trimmingCharacters(in: .whitespaces) ?? ""

var longestSecret = 0
var keypairs = lines
    .compactMap { (line: Substring) -> (key: String, value: String)? in
        if !line.hasPrefix("export ") {
            return nil
        }
        let line = line.dropFirst("export ".count)
        let splits = line.split(separator: "=", maxSplits: 1)
        var key = splits[0]
        if key.hasPrefix(prefix) {
            key = key.dropFirst(prefix.count)
            // if key still begins with an underscore, lets remove that also
            if key.hasPrefix("_") {
                key = key.dropFirst()
            }
        }

        let value: String
        if splits.count == 2 {
            value = splits[1].trimmingCharacters(in: quotesCharacterSet)
        } else if let envValue = ProcessInfo.processInfo.environment[String(splits[0])] {
            value = envValue
        } else {
            print("warning: expected to find environment value for key \(splits[0])")
            value = "" // If we've got `export KEY` with no value, it's likely intentionally left blank
        }

        longestSecret = max(longestSecret, value.utf8.count)
        return (key: key.lowercased().camelized, value: String(value))
    }

// Success, the env file has no secrets, therefore we are done?
guard !keypairs.isEmpty else {
    print("warning: No keys found in env file at path \(envPath)")
    exit(0) 
}

// Generate a random cypher equal in length to the longest secret
var cypher = Data(count: longestSecret)
cypher.withUnsafeMutableBytes {
    let result = SecRandomCopyBytes(kSecRandomDefault, longestSecret, $0.baseAddress!)
    precondition(result == errSecSuccess, "Failed to generate a random cypher using SecRandomCopyBytes")
}

/// - Note: This is a lazy encryption scheme, simply using an XOR with the cypher
func encrypted(_ text: String) -> Data {
    let text = Array(text.utf8)
    let key = Array(cypher)
    var output: [UTF8.CodeUnit] = []
    for (offset, ch) in text.enumerated() {
        output.append(ch ^ key[offset % key.count])
    }
    return Data(output)
}

func encoded(_ data: Data) -> String {
    data.base64EncodedString()
}

keypairs = keypairs
    .map({ (key: $0, value: encrypted($1)) })
    .map({ (key: $0, value: encoded($1)) })

let swiftHeader = """
    // This file is automatically generated

    import struct Foundation.Data

    private func secret(_ secret: String) -> String {
        let data = Data(base64Encoded: secret)
        guard let data else {
            fatalError("Failed to decode a secret!")
        }

        func decrypt(_ data: Data) -> String {
            let key = Data(base64Encoded: "\(cypher.base64EncodedString())")!
            var output: [UTF8.CodeUnit] = []
            for (offset, ch) in data.enumerated() {
                output.append(ch ^ key[offset % key.count])
            }
            return String(bytes: output, encoding: .utf8)!
        }

        return decrypt(data)
    }

    """

let enumMembers = keypairs.map { key, value in
    """
        static let \(key) = secret("\(value)")
    """
}
    .joined(separator: "\n")

let swiftSecretsEnum = """

    enum Secrets {
    \(enumMembers)
    }


    """

let swiftFile = swiftHeader + swiftSecretsEnum
guard let data = swiftFile.data(using: .utf8) else {
    print("warning: Generated file failed to encode into UTF8")
    exit(1)
}

let url = URL(fileURLWithPath: outPath)
do {
    try data.write(to: url)
    print("Output at \(outPath)")
} catch {
    print("error: Writing file failed with: \(error.localizedDescription)")
}

// MARK: - Extensions

extension String {
    var uppercasingFirst: String {
        return prefix(1).uppercased() + dropFirst()
    }

    var lowercasingFirst: String {
        return prefix(1).lowercased() + dropFirst()
    }
}

extension Array<String> {
    subscript(safe index: Index) -> String? {
        guard indices.contains(index) else { return nil }
        return self[index]
    }
}

extension StringProtocol {
    var camelized: String {
        guard !isEmpty else {
            return ""
        }

        let parts = self.components(separatedBy: CharacterSet.alphanumerics.inverted)

        let first = String(describing: parts.first!).lowercasingFirst
        let rest = parts.dropFirst().map({String($0).uppercasingFirst})

        return ([first] + rest).joined(separator: "")
    }

    func suffix(from prefix: String) -> String {
        let index = index(startIndex, offsetBy: prefix.count)
        return String(self.suffix(from: index))
    }
}
